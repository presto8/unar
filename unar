#!/usr/bin/env python

import argparse
import os
import subprocess
import sys
import time
from contextlib import contextmanager
from dataclasses import dataclass
from typing import Optional


class Fail(Exception):
    pass


@dataclass
class ExtractArchiveResult:
    finaldir: str
    filecount: int


@dataclass
class ParsedPath:
    extension: str
    basepath: str
    extract_command: str
    basedir: str
    abspath: str


@contextmanager
def cwd(path):
    oldpwd = os.getcwd()
    try:
        os.chdir(path)
        yield
    finally:
        os.chdir(oldpwd)


def scantree(path, follow_symlinks=False):
    for entry in os.scandir(path):
        if entry.is_dir(follow_symlinks=follow_symlinks):
            yield from scantree(entry.path, follow_symlinks=follow_symlinks)
        else:
            yield entry


# Returns paths sorted in ascending time (oldest first)
def scantree_mtime(path):
    entries = list(scantree(path))
    return sorted(entries, key=lambda x: x.stat().st_mtime)


def parse_path(path) -> Optional[ParsedPath]:
    m = {
        ".zip": "unzip",
        ".tar": "tar xf",
        ".tar.bz2": "tar xf",
        ".tar.gz": "tar xf",
        ".rar": "unrar x",
        ".7z": "7z x",
        ".7zip": "7z x",
    }

    for ext, cmd in m.items():
        if path.endswith(ext):
            return ParsedPath(extension=ext, extract_command=cmd,
                              basepath=os.path.basename(path).rstrip(ext),
                              basedir=os.path.dirname(os.path.abspath(path)),
                              abspath=os.path.abspath(path))
    return None


def extract_to_temp(parsed: ParsedPath) -> str:
    extract_dir = os.path.join(parsed.basedir, parsed.basepath + "." + time.strftime("%Y%m%dT%H%M%S"))
    assert not os.path.exists(extract_dir)
    os.makedirs(extract_dir)
    with cwd(extract_dir):
        subprocess.check_output(parsed.extract_command.split() + [parsed.abspath])
    return extract_dir


def extract_archive(path) -> ExtractArchiveResult:
    parsed = parse_path(path)
    if parsed is None:
        print(f"encountered an error while extracting: {path}, skipping")
        raise Exception("TODO: figure out return failure here.")
    print(parsed)
    temp_dir = extract_to_temp(parsed)
    print("extracted to:", temp_dir)
    return ExtractArchiveResult(finaldir="TODO", filecount=0)


def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument('files', nargs='+', help='archive files to extract')
    parser.add_argument('--verbose', default=False, action='store_true', help='show more detailed messages')
    return parser.parse_args()


def main():
    for path in ARGS.files:
        result = extract_archive(path)
        print(f"{path} -> {result.finaldir} [{result.filecount} files]")


if __name__ == '__main__':
    try:
        ARGS = parse_args()
        main()
    except Fail as f:
        print(*f.args, file=sys.stderr)
        sys.exit(1)
    except KeyboardInterrupt:
        print("Ctrl+C")
